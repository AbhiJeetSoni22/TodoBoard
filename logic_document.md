# Logic Document: Real-Time Collaborative To-Do Board

## Smart Assign Logic
The Smart Assign feature automatically assigns a task to the user with the fewest active tasks (tasks in "Todo" or "In Progress" status) to balance workload across team members. Here’s how it works:

When a user clicks the "Smart Assign" button on a task, the frontend sends a POST request to the backend endpoint `/api/tasks/:taskId/smart-assign`. The backend retrieves all users from the database and counts their active tasks by querying the `tasks` collection for documents where the `assignedUser` matches the user’s ID and the `status` is either "Todo" or "In Progress". The user with the lowest task count is selected. If multiple users have the same number of tasks (e.g., zero tasks), the system chooses the user whose name comes first alphabetically to ensure a consistent choice. The task’s `assignedUser` field is updated with the selected user’s ID, and the `lastModified` timestamp is set to the current time. The updated task is saved to the database and broadcast to all connected clients via Socket.IO, ensuring real-time updates. An action log entry is created, recording the user who initiated the action and the task’s new assignee (e.g., "Smart-assigned task: Plan Meeting to Rohit").

**Example**: Suppose there are three users: Abhijeet (2 tasks), user1 (1 task), and Rohit (0 tasks). When Abhijeet clicks Smart Assign on the task "Plan Meeting," the backend identifies Rohit as having the fewest tasks (0). The task is assigned to Rohit, and the Activity Log shows: "Abhijeet smart-assigned: Smart-assigned task: Plan Meeting to Rohit." All users see the task card update to show "Assigned: Rohit" in real time.

## Conflict Handling Logic
Conflict handling ensures that when multiple users edit the same task simultaneously, conflicts are detected and resolved without data loss. The system uses a timestamp-based approach to manage concurrent edits.

Each task in the database has a `lastModified` timestamp. When a user edits a task (e.g., changes its title or priority), the frontend sends a PUT request to `/api/tasks/:id` with the updated task data and the task’s current `lastModified` timestamp. The backend checks if the provided `lastModified` matches the task’s current `lastModified` in the database. If the client’s timestamp is older, it indicates another user has modified the task since the client last fetched it, triggering a conflict. The backend responds with a 409 Conflict status, including both the current database version and the client’s version of the task. The frontend then displays a modal showing both versions’ fields (title, description, priority, assigned user, status). The user can choose to merge changes (e.g., combine their title with the server’s priority) or overwrite the server’s version with their own. The chosen resolution is sent to the backend in a new PUT request, updating the task with a new `lastModified` timestamp. The updated task is broadcast to all clients via Socket.IO for real-time synchronization.

**Example**: User1 edits the task "Plan Meeting" to change its description to "Discuss project timeline" at time T1. Simultaneously, User2 changes the priority to "High" at T2 (T2 > T1). When User1 submits their edit, the backend detects a conflict because their `lastModified` (T1) is older than the database’s (T2). The frontend shows a modal comparing both versions. User1 chooses to merge, keeping their description and accepting User2’s priority. The task is updated, and all users see the resolved task in real time.